{"ast":null,"code":"import _classPrivateFieldLooseBase from \"C:/Users/user/hub/web-7/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js\";\nimport _classPrivateFieldLooseKey from \"C:/Users/user/hub/web-7/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js\";\nvar _jsxFileName = \"C:\\\\Users\\\\user\\\\hub\\\\web-7\\\\src\\\\pages\\\\TodoPage\\\\TodoPage.jsx\";\nimport { Component } from 'react';\n\n// Импорт другой компоненты\nimport { Deletable } from '../../widgets/Deletable/Deletable';\n\n// Импорт файла со стилями\nimport './style.css';\n\n// Страничка туду\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _handleCompletedChange = /*#__PURE__*/_classPrivateFieldLooseKey(\"handleCompletedChange\");\nvar _handlerTodoDelete = /*#__PURE__*/_classPrivateFieldLooseKey(\"handlerTodoDelete\");\nexport class TodoPage extends Component {\n  constructor(props) {\n    super(props);\n\n    // Инициализируем состояние страницы\n    Object.defineProperty(this, _handlerTodoDelete, {\n      value: _handlerTodoDelete2\n    });\n    Object.defineProperty(this, _handleCompletedChange, {\n      value: _handleCompletedChange2\n    });\n    // Биндим контекст this. Вынесли bind за пределы метода render, чтобы не пересоздавать\n    // объект функции с привязанным контекстом для каждой todo из массива. Такой подход передачи\n    // пропсов так же является правильным и с точки зрения оптимизаций react\n    // Подробнее про key-проп https://www.youtube.com/watch?v=OtAlPwW8DNU&t=409s\n    this.delete = _classPrivateFieldLooseBase(this, _handlerTodoDelete)[_handlerTodoDelete].bind(this);\n    this.state = {\n      // Массив тудушек\n      todos: [],\n      // Флаг, указывающий, что идет процесс загрузки данных\n      isLoading: true\n    };\n  }\n  // Метод жизненного цикла, который вызывается один раз для компоненты после ее вмонтирования\n  componentDidMount() {\n    // Асинхронный вызов получения данных тудушек. Возвращает объект Promise, для которого\n    // в случае успешного завершения запроса вызовется обработчик переданный в метод then\n    fetch('https://jsonplaceholder.typicode.com/todos')\n    // Вызов обработчика, который парсит тело ответа. Так как метод json является асинхронным (возвращает Promise),\n    // для него необходимо определить обработчик с помощью повторного вызова метода then\n    .then(response => response.json())\n    // Стрелочная функция на вход принимает уже обработанное тело ответа\n    .then(todos => {\n      // Обновляем состояние страницы\n      this.setState({\n        todos: todos,\n        // Сбрасываем флаг из loading\n        isLoading: false\n      });\n    })\n    // Обработчик на тот случай, если асинхронный вызов по каким-то причином завершился с ошибкой,\n    // например, сервер не доступен\n    .catch(() => {\n      console.log('Произошла ошибка');\n    });\n  }\n  render() {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"todo-page\",\n      children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n        children: \"Todo page\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 59,\n        columnNumber: 17\n      }, this), this.state.isLoading && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"loader\",\n        children: \"\\u0417\\u0430\\u0433\\u0440\\u0443\\u0437\\u043A\\u0430...\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 63,\n        columnNumber: 21\n      }, this) ||\n      // Метод map позволяет перебрать массив, и на ее основе сформировать новый массив\n      // В данном случае формируем массив JSX-объектов. Метод map принимает функцию-обработчик,\n      // которая принимает очередной элемент и индекс этого элемента \n      this.state.todos.map((todo, index) => {\n        return (\n          /*#__PURE__*/\n          // Компонента, которая добавляет элементу todo функционал удаления.\n          // Внутрь JSX-объекта можно передать другой JSX-объект или список объектов.\n          // Эти объекты будут записаны в props.children\n          _jsxDEV(Deletable, {\n            title: todo.title,\n            id: todo.id\n            // Передаем обработчик удаления\n            ,\n            deleteHandler: this.delete\n\n            // Подробнее про key-проп https://www.youtube.com/watch?v=OtAlPwW8DNU&t=409s\n            ,\n            children: /*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"todo\",\n              children: [/*#__PURE__*/_jsxDEV(\"input\", {\n                type: \"checkbox\"\n                // Осуществляем контроль отображения компоненты\n                ,\n                checked: todo.completed,\n                onChange: _classPrivateFieldLooseBase(this, _handleCompletedChange)[_handleCompletedChange].bind(this, index)\n                // В завимисоти от состояния меняет CSS-стили\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 84,\n                columnNumber: 41\n              }, this), \" \", /*#__PURE__*/_jsxDEV(\"span\", {\n                style: {\n                  color: todo.completed ? 'green' : 'red'\n                },\n                children: todo.title\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 90,\n                columnNumber: 44\n              }, this)]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 83,\n              columnNumber: 37\n            }, this)\n          }, todo.id, false, {\n            fileName: _jsxFileName,\n            lineNumber: 75,\n            columnNumber: 29\n          }, this)\n        );\n      })]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 58,\n      columnNumber: 13\n    }, this);\n  }\n}\nfunction _handleCompletedChange2(index) {\n  // Документация реакт по обновлению состояния списка https://react.dev/learn/updating-arrays-in-state\n  // Правильное обновление состояния сложных объект подразумевает, что мы должны изменить ссылку на сложный\n  // объект, иначе могут возникнуть различные проблемы с перерисовкой приложения. Обычно react-разработчики стараются\n  // оптимизировать количество перерисовок компонент, сравнивая предыдущие и текущие пропсы. Сравнение объектов в JS\n  // является поверхностным, то есть он сравнивает только ссылки на равенство. Если мы напрямую будем мутировать this.state.todos,\n  // и, например, у нас бы была оптимизированная компонента TodosList, которая на вход принимала бы массив todos, то приложение бы не обновлялось,\n  // даже если бы мы изменили хотя бы один объект в массиве. Но ссылка на сходный массив не изменилась, поэтому перерисовки интефейса не произойдет\n\n  // Правильным подходом является создание нового массива на основе данных сещствующего массива. Массивы в JS хранят ссылки на объекты.\n  // Вызов метода slice позволит создать новый массив на основе старого, путем копирования ссылок на объекты, то есть копирование здесь поверхностное,\n  // но с точки зрения работы с состоянием реакта мы все сделали правильно, поскольку мы не изменяем исходный объект, а создаем на его основе новый\n  // Такая здесь парадигма :)\n\n  // Очень хороший видеоролик, который показывает как правильно работать со сложным состоянием: https://www.youtube.com/watch?v=a2DkRBnp4ns\n\n  // Так же новые объекты массива создают методы map и filter. Их тоже можно использовать для создания нового объекта массива\n  // (в зависимости от задачи: отфильтровать массив или на основе существующего массива обработать каждый элемент и получить новый массив)\n  const updatedTodos = this.state.todos.slice();\n\n  // Здесь так же приведен объект, как правильно создавать новый объект на основе существующего.\n  // \"...\" это spread-оператор или деструктуризация, которая позволяет разложить все свойства объекта и на их основе сконструировать новый объект.\n  // Порядок при этом важен. ```completed: !updatedTodos[index].completed``` должно идти позже spread, иначе для нового объекта todo свойство completed\n  // будет взято из старого объекта\n  updatedTodos[index] = {\n    ...updatedTodos[index],\n    completed: !updatedTodos[index].completed\n  };\n  this.setState({\n    todos: updatedTodos\n  });\n}\nfunction _handlerTodoDelete2(id) {\n  // Реализуем удаление элемента с помощью метода filter, который возвращает новый массив, состоящий из элементов,\n  // прошедших фильтрацию\n  const updatedTodos = this.state.todos.filter(todo => {\n    return todo.id !== id;\n  });\n  this.setState({\n    todos: updatedTodos\n  });\n}","map":{"version":3,"names":["Component","Deletable","jsxDEV","_jsxDEV","_handleCompletedChange","_classPrivateFieldLooseKey","_handlerTodoDelete","TodoPage","constructor","props","Object","defineProperty","value","_handlerTodoDelete2","_handleCompletedChange2","delete","_classPrivateFieldLooseBase","bind","state","todos","isLoading","componentDidMount","fetch","then","response","json","setState","catch","console","log","render","className","children","fileName","_jsxFileName","lineNumber","columnNumber","map","todo","index","title","id","deleteHandler","type","checked","completed","onChange","style","color","updatedTodos","slice","filter"],"sources":["C:/Users/user/hub/web-7/src/pages/TodoPage/TodoPage.jsx"],"sourcesContent":["import { Component } from 'react'\r\n\r\n// Импорт другой компоненты\r\nimport { Deletable } from '../../widgets/Deletable/Deletable';\r\n\r\n// Импорт файла со стилями\r\nimport './style.css'\r\n\r\n// Страничка туду\r\nexport class TodoPage extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        // Инициализируем состояние страницы\r\n        this.state = {\r\n            // Массив тудушек\r\n            todos: [],\r\n\r\n            // Флаг, указывающий, что идет процесс загрузки данных\r\n            isLoading: true\r\n        };\r\n    }\r\n\r\n    // Биндим контекст this. Вынесли bind за пределы метода render, чтобы не пересоздавать\r\n    // объект функции с привязанным контекстом для каждой todo из массива. Такой подход передачи\r\n    // пропсов так же является правильным и с точки зрения оптимизаций react\r\n    // Подробнее про key-проп https://www.youtube.com/watch?v=OtAlPwW8DNU&t=409s\r\n    delete = this.#handlerTodoDelete.bind(this)\r\n\r\n    // Метод жизненного цикла, который вызывается один раз для компоненты после ее вмонтирования\r\n    componentDidMount() {\r\n        // Асинхронный вызов получения данных тудушек. Возвращает объект Promise, для которого\r\n        // в случае успешного завершения запроса вызовется обработчик переданный в метод then\r\n        fetch('https://jsonplaceholder.typicode.com/todos')\r\n            // Вызов обработчика, который парсит тело ответа. Так как метод json является асинхронным (возвращает Promise),\r\n            // для него необходимо определить обработчик с помощью повторного вызова метода then\r\n            .then((response) => response.json())\r\n            // Стрелочная функция на вход принимает уже обработанное тело ответа\r\n            .then((todos) => {\r\n\r\n                // Обновляем состояние страницы\r\n                this.setState({\r\n                    todos: todos,\r\n\r\n                    // Сбрасываем флаг из loading\r\n                    isLoading: false\r\n                });\r\n            })\r\n            // Обработчик на тот случай, если асинхронный вызов по каким-то причином завершился с ошибкой,\r\n            // например, сервер не доступен\r\n            .catch(() => {\r\n                console.log('Произошла ошибка')\r\n            });\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className='todo-page'>\r\n                <h2>Todo page</h2>\r\n\r\n                {/* // if-else отрисовка */}\r\n                {this.state.isLoading && (\r\n                    <div className='loader'>\r\n                        Загрузка...\r\n                    </div>\r\n                ) || (\r\n                    // Метод map позволяет перебрать массив, и на ее основе сформировать новый массив\r\n                    // В данном случае формируем массив JSX-объектов. Метод map принимает функцию-обработчик,\r\n                    // которая принимает очередной элемент и индекс этого элемента \r\n                    this.state.todos.map((todo, index) => {\r\n                        return (\r\n                            // Компонента, которая добавляет элементу todo функционал удаления.\r\n                            // Внутрь JSX-объекта можно передать другой JSX-объект или список объектов.\r\n                            // Эти объекты будут записаны в props.children\r\n                            <Deletable\r\n                                title={todo.title}\r\n                                id={todo.id}\r\n                                // Передаем обработчик удаления\r\n                                deleteHandler={this.delete}\r\n\r\n                                // Подробнее про key-проп https://www.youtube.com/watch?v=OtAlPwW8DNU&t=409s\r\n                                key={todo.id}>\r\n                                    <div className='todo'>\r\n                                        <input\r\n                                            type='checkbox'\r\n                                            // Осуществляем контроль отображения компоненты\r\n                                            checked={todo.completed}\r\n                                            onChange={this.#handleCompletedChange.bind(this, index)}\r\n                                            // В завимисоти от состояния меняет CSS-стили\r\n                                        /> <span style={{ color: todo.completed ? 'green' : 'red' }}>{todo.title}</span>\r\n                                    </div>\r\n                            </Deletable>\r\n                        );\r\n                    })\r\n                )}\r\n            </div>\r\n        );\r\n\r\n    }\r\n\r\n    #handleCompletedChange(index) {\r\n        // Документация реакт по обновлению состояния списка https://react.dev/learn/updating-arrays-in-state\r\n        // Правильное обновление состояния сложных объект подразумевает, что мы должны изменить ссылку на сложный\r\n        // объект, иначе могут возникнуть различные проблемы с перерисовкой приложения. Обычно react-разработчики стараются\r\n        // оптимизировать количество перерисовок компонент, сравнивая предыдущие и текущие пропсы. Сравнение объектов в JS\r\n        // является поверхностным, то есть он сравнивает только ссылки на равенство. Если мы напрямую будем мутировать this.state.todos,\r\n        // и, например, у нас бы была оптимизированная компонента TodosList, которая на вход принимала бы массив todos, то приложение бы не обновлялось,\r\n        // даже если бы мы изменили хотя бы один объект в массиве. Но ссылка на сходный массив не изменилась, поэтому перерисовки интефейса не произойдет\r\n\r\n        // Правильным подходом является создание нового массива на основе данных сещствующего массива. Массивы в JS хранят ссылки на объекты.\r\n        // Вызов метода slice позволит создать новый массив на основе старого, путем копирования ссылок на объекты, то есть копирование здесь поверхностное,\r\n        // но с точки зрения работы с состоянием реакта мы все сделали правильно, поскольку мы не изменяем исходный объект, а создаем на его основе новый\r\n        // Такая здесь парадигма :)\r\n\r\n        // Очень хороший видеоролик, который показывает как правильно работать со сложным состоянием: https://www.youtube.com/watch?v=a2DkRBnp4ns\r\n\r\n        // Так же новые объекты массива создают методы map и filter. Их тоже можно использовать для создания нового объекта массива\r\n        // (в зависимости от задачи: отфильтровать массив или на основе существующего массива обработать каждый элемент и получить новый массив)\r\n        const updatedTodos = this.state.todos.slice();\r\n\r\n        // Здесь так же приведен объект, как правильно создавать новый объект на основе существующего.\r\n        // \"...\" это spread-оператор или деструктуризация, которая позволяет разложить все свойства объекта и на их основе сконструировать новый объект.\r\n        // Порядок при этом важен. ```completed: !updatedTodos[index].completed``` должно идти позже spread, иначе для нового объекта todo свойство completed\r\n        // будет взято из старого объекта\r\n        updatedTodos[index] = {\r\n            ...updatedTodos[index],\r\n            completed: !updatedTodos[index].completed\r\n        }\r\n\r\n        this.setState({\r\n            todos: updatedTodos\r\n        });\r\n    }\r\n\r\n    #handlerTodoDelete(id) {\r\n        // Реализуем удаление элемента с помощью метода filter, который возвращает новый массив, состоящий из элементов,\r\n        // прошедших фильтрацию\r\n        const updatedTodos = this.state.todos.filter((todo) => {\r\n            return todo.id !== id;\r\n        })\r\n\r\n        this.setState({\r\n            todos: updatedTodos\r\n        });\r\n    }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}