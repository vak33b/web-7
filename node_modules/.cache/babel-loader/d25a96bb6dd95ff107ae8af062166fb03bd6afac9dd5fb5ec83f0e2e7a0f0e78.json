{"ast":null,"code":"import _classPrivateFieldLooseBase from\"C:/Users/user/hub/web-7/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js\";import _classPrivateFieldLooseKey from\"C:/Users/user/hub/web-7/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js\";import{Component}from'react';// Импорт другой компоненты\nimport{Deletable}from'../../widgets/Deletable/Deletable';// Импорт файла со стилями\nimport'./style.css';// Страничка туду\nimport{jsx as _jsx,jsxs as _jsxs}from\"react/jsx-runtime\";var _handleCompletedChange=/*#__PURE__*/_classPrivateFieldLooseKey(\"handleCompletedChange\");var _handlerTodoDelete=/*#__PURE__*/_classPrivateFieldLooseKey(\"handlerTodoDelete\");export class TodoPage extends Component{constructor(props){super(props);// Инициализируем состояние страницы\nObject.defineProperty(this,_handlerTodoDelete,{value:_handlerTodoDelete2});Object.defineProperty(this,_handleCompletedChange,{value:_handleCompletedChange2});// Биндим контекст this. Вынесли bind за пределы метода render, чтобы не пересоздавать\n// объект функции с привязанным контекстом для каждой todo из массива. Такой подход передачи\n// пропсов так же является правильным и с точки зрения оптимизаций react\n// Подробнее про key-проп https://www.youtube.com/watch?v=OtAlPwW8DNU&t=409s\nthis.delete=_classPrivateFieldLooseBase(this,_handlerTodoDelete)[_handlerTodoDelete].bind(this);this.state={// Массив тудушек\ntodos:[],// Флаг, указывающий, что идет процесс загрузки данных\nisLoading:true};}// Метод жизненного цикла, который вызывается один раз для компоненты после ее вмонтирования\ncomponentDidMount(){// Асинхронный вызов получения данных тудушек. Возвращает объект Promise, для которого\n// в случае успешного завершения запроса вызовется обработчик переданный в метод then\nfetch('https://jsonplaceholder.typicode.com/todos')// Вызов обработчика, который парсит тело ответа. Так как метод json является асинхронным (возвращает Promise),\n// для него необходимо определить обработчик с помощью повторного вызова метода then\n.then(response=>response.json())// Стрелочная функция на вход принимает уже обработанное тело ответа\n.then(todos=>{// Обновляем состояние страницы\nthis.setState({todos:todos,// Сбрасываем флаг из loading\nisLoading:false});})// Обработчик на тот случай, если асинхронный вызов по каким-то причином завершился с ошибкой,\n// например, сервер не доступен\n.catch(()=>{console.log('Произошла ошибка');});}render(){return/*#__PURE__*/_jsxs(\"div\",{className:\"todo-page\",children:[/*#__PURE__*/_jsx(\"h2\",{children:\"Todo page\"}),this.state.isLoading&&/*#__PURE__*/_jsx(\"div\",{className:\"loader\",children:\"\\u0417\\u0430\\u0433\\u0440\\u0443\\u0437\\u043A\\u0430...\"})||// Метод map позволяет перебрать массив, и на ее основе сформировать новый массив\n// В данном случае формируем массив JSX-объектов. Метод map принимает функцию-обработчик,\n// которая принимает очередной элемент и индекс этого элемента \nthis.state.todos.map((todo,index)=>{return(/*#__PURE__*/// Компонента, которая добавляет элементу todo функционал удаления.\n// Внутрь JSX-объекта можно передать другой JSX-объект или список объектов.\n// Эти объекты будут записаны в props.children\n_jsx(Deletable,{title:todo.title,id:todo.id// Передаем обработчик удаления\n,deleteHandler:this.delete// Подробнее про key-проп https://www.youtube.com/watch?v=OtAlPwW8DNU&t=409s\n,children:/*#__PURE__*/_jsxs(\"div\",{className:\"todo\",children:[/*#__PURE__*/_jsx(\"input\",{type:\"checkbox\"// Осуществляем контроль отображения компоненты\n,checked:todo.completed,onChange:_classPrivateFieldLooseBase(this,_handleCompletedChange)[_handleCompletedChange].bind(this,index)// В завимисоти от состояния меняет CSS-стили\n}),\" \",/*#__PURE__*/_jsx(\"span\",{style:{color:todo.completed?'green':'red'},children:todo.title})]})},todo.id));})]});}}function _handleCompletedChange2(index){// Документация реакт по обновлению состояния списка https://react.dev/learn/updating-arrays-in-state\n// Правильное обновление состояния сложных объект подразумевает, что мы должны изменить ссылку на сложный\n// объект, иначе могут возникнуть различные проблемы с перерисовкой приложения. Обычно react-разработчики стараются\n// оптимизировать количество перерисовок компонент, сравнивая предыдущие и текущие пропсы. Сравнение объектов в JS\n// является поверхностным, то есть он сравнивает только ссылки на равенство. Если мы напрямую будем мутировать this.state.todos,\n// и, например, у нас бы была оптимизированная компонента TodosList, которая на вход принимала бы массив todos, то приложение бы не обновлялось,\n// даже если бы мы изменили хотя бы один объект в массиве. Но ссылка на сходный массив не изменилась, поэтому перерисовки интефейса не произойдет\n// Правильным подходом является создание нового массива на основе данных сещствующего массива. Массивы в JS хранят ссылки на объекты.\n// Вызов метода slice позволит создать новый массив на основе старого, путем копирования ссылок на объекты, то есть копирование здесь поверхностное,\n// но с точки зрения работы с состоянием реакта мы все сделали правильно, поскольку мы не изменяем исходный объект, а создаем на его основе новый\n// Такая здесь парадигма :)\n// Очень хороший видеоролик, который показывает как правильно работать со сложным состоянием: https://www.youtube.com/watch?v=a2DkRBnp4ns\n// Так же новые объекты массива создают методы map и filter. Их тоже можно использовать для создания нового объекта массива\n// (в зависимости от задачи: отфильтровать массив или на основе существующего массива обработать каждый элемент и получить новый массив)\nconst updatedTodos=this.state.todos.slice();// Здесь так же приведен объект, как правильно создавать новый объект на основе существующего.\n// \"...\" это spread-оператор или деструктуризация, которая позволяет разложить все свойства объекта и на их основе сконструировать новый объект.\n// Порядок при этом важен. ```completed: !updatedTodos[index].completed``` должно идти позже spread, иначе для нового объекта todo свойство completed\n// будет взято из старого объекта\nupdatedTodos[index]={...updatedTodos[index],completed:!updatedTodos[index].completed};this.setState({todos:updatedTodos});}function _handlerTodoDelete2(id){// Реализуем удаление элемента с помощью метода filter, который возвращает новый массив, состоящий из элементов,\n// прошедших фильтрацию\nconst updatedTodos=this.state.todos.filter(todo=>{return todo.id!==id;});this.setState({todos:updatedTodos});}","map":{"version":3,"names":["Component","Deletable","jsx","_jsx","jsxs","_jsxs","_handleCompletedChange","_classPrivateFieldLooseKey","_handlerTodoDelete","TodoPage","constructor","props","Object","defineProperty","value","_handlerTodoDelete2","_handleCompletedChange2","delete","_classPrivateFieldLooseBase","bind","state","todos","isLoading","componentDidMount","fetch","then","response","json","setState","catch","console","log","render","className","children","map","todo","index","title","id","deleteHandler","type","checked","completed","onChange","style","color","updatedTodos","slice","filter"],"sources":["C:/Users/user/hub/web-7/src/pages/TodoPage/TodoPage.jsx"],"sourcesContent":["import { Component } from 'react'\r\n\r\n// Импорт другой компоненты\r\nimport { Deletable } from '../../widgets/Deletable/Deletable';\r\n\r\n// Импорт файла со стилями\r\nimport './style.css'\r\n\r\n// Страничка туду\r\nexport class TodoPage extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        // Инициализируем состояние страницы\r\n        this.state = {\r\n            // Массив тудушек\r\n            todos: [],\r\n\r\n            // Флаг, указывающий, что идет процесс загрузки данных\r\n            isLoading: true\r\n        };\r\n    }\r\n\r\n    // Биндим контекст this. Вынесли bind за пределы метода render, чтобы не пересоздавать\r\n    // объект функции с привязанным контекстом для каждой todo из массива. Такой подход передачи\r\n    // пропсов так же является правильным и с точки зрения оптимизаций react\r\n    // Подробнее про key-проп https://www.youtube.com/watch?v=OtAlPwW8DNU&t=409s\r\n    delete = this.#handlerTodoDelete.bind(this)\r\n\r\n    // Метод жизненного цикла, который вызывается один раз для компоненты после ее вмонтирования\r\n    componentDidMount() {\r\n        // Асинхронный вызов получения данных тудушек. Возвращает объект Promise, для которого\r\n        // в случае успешного завершения запроса вызовется обработчик переданный в метод then\r\n        fetch('https://jsonplaceholder.typicode.com/todos')\r\n            // Вызов обработчика, который парсит тело ответа. Так как метод json является асинхронным (возвращает Promise),\r\n            // для него необходимо определить обработчик с помощью повторного вызова метода then\r\n            .then((response) => response.json())\r\n            // Стрелочная функция на вход принимает уже обработанное тело ответа\r\n            .then((todos) => {\r\n\r\n                // Обновляем состояние страницы\r\n                this.setState({\r\n                    todos: todos,\r\n\r\n                    // Сбрасываем флаг из loading\r\n                    isLoading: false\r\n                });\r\n            })\r\n            // Обработчик на тот случай, если асинхронный вызов по каким-то причином завершился с ошибкой,\r\n            // например, сервер не доступен\r\n            .catch(() => {\r\n                console.log('Произошла ошибка')\r\n            });\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className='todo-page'>\r\n                <h2>Todo page</h2>\r\n\r\n                {/* // if-else отрисовка */}\r\n                {this.state.isLoading && (\r\n                    <div className='loader'>\r\n                        Загрузка...\r\n                    </div>\r\n                ) || (\r\n                    // Метод map позволяет перебрать массив, и на ее основе сформировать новый массив\r\n                    // В данном случае формируем массив JSX-объектов. Метод map принимает функцию-обработчик,\r\n                    // которая принимает очередной элемент и индекс этого элемента \r\n                    this.state.todos.map((todo, index) => {\r\n                        return (\r\n                            // Компонента, которая добавляет элементу todo функционал удаления.\r\n                            // Внутрь JSX-объекта можно передать другой JSX-объект или список объектов.\r\n                            // Эти объекты будут записаны в props.children\r\n                            <Deletable\r\n                                title={todo.title}\r\n                                id={todo.id}\r\n                                // Передаем обработчик удаления\r\n                                deleteHandler={this.delete}\r\n\r\n                                // Подробнее про key-проп https://www.youtube.com/watch?v=OtAlPwW8DNU&t=409s\r\n                                key={todo.id}>\r\n                                    <div className='todo'>\r\n                                        <input\r\n                                            type='checkbox'\r\n                                            // Осуществляем контроль отображения компоненты\r\n                                            checked={todo.completed}\r\n                                            onChange={this.#handleCompletedChange.bind(this, index)}\r\n                                            // В завимисоти от состояния меняет CSS-стили\r\n                                        /> <span style={{ color: todo.completed ? 'green' : 'red' }}>{todo.title}</span>\r\n                                    </div>\r\n                            </Deletable>\r\n                        );\r\n                    })\r\n                )}\r\n            </div>\r\n        );\r\n\r\n    }\r\n\r\n    #handleCompletedChange(index) {\r\n        // Документация реакт по обновлению состояния списка https://react.dev/learn/updating-arrays-in-state\r\n        // Правильное обновление состояния сложных объект подразумевает, что мы должны изменить ссылку на сложный\r\n        // объект, иначе могут возникнуть различные проблемы с перерисовкой приложения. Обычно react-разработчики стараются\r\n        // оптимизировать количество перерисовок компонент, сравнивая предыдущие и текущие пропсы. Сравнение объектов в JS\r\n        // является поверхностным, то есть он сравнивает только ссылки на равенство. Если мы напрямую будем мутировать this.state.todos,\r\n        // и, например, у нас бы была оптимизированная компонента TodosList, которая на вход принимала бы массив todos, то приложение бы не обновлялось,\r\n        // даже если бы мы изменили хотя бы один объект в массиве. Но ссылка на сходный массив не изменилась, поэтому перерисовки интефейса не произойдет\r\n\r\n        // Правильным подходом является создание нового массива на основе данных сещствующего массива. Массивы в JS хранят ссылки на объекты.\r\n        // Вызов метода slice позволит создать новый массив на основе старого, путем копирования ссылок на объекты, то есть копирование здесь поверхностное,\r\n        // но с точки зрения работы с состоянием реакта мы все сделали правильно, поскольку мы не изменяем исходный объект, а создаем на его основе новый\r\n        // Такая здесь парадигма :)\r\n\r\n        // Очень хороший видеоролик, который показывает как правильно работать со сложным состоянием: https://www.youtube.com/watch?v=a2DkRBnp4ns\r\n\r\n        // Так же новые объекты массива создают методы map и filter. Их тоже можно использовать для создания нового объекта массива\r\n        // (в зависимости от задачи: отфильтровать массив или на основе существующего массива обработать каждый элемент и получить новый массив)\r\n        const updatedTodos = this.state.todos.slice();\r\n\r\n        // Здесь так же приведен объект, как правильно создавать новый объект на основе существующего.\r\n        // \"...\" это spread-оператор или деструктуризация, которая позволяет разложить все свойства объекта и на их основе сконструировать новый объект.\r\n        // Порядок при этом важен. ```completed: !updatedTodos[index].completed``` должно идти позже spread, иначе для нового объекта todo свойство completed\r\n        // будет взято из старого объекта\r\n        updatedTodos[index] = {\r\n            ...updatedTodos[index],\r\n            completed: !updatedTodos[index].completed\r\n        }\r\n\r\n        this.setState({\r\n            todos: updatedTodos\r\n        });\r\n    }\r\n\r\n    #handlerTodoDelete(id) {\r\n        // Реализуем удаление элемента с помощью метода filter, который возвращает новый массив, состоящий из элементов,\r\n        // прошедших фильтрацию\r\n        const updatedTodos = this.state.todos.filter((todo) => {\r\n            return todo.id !== id;\r\n        })\r\n\r\n        this.setState({\r\n            todos: updatedTodos\r\n        });\r\n    }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}