{"ast":null,"code":"import _classPrivateFieldLooseBase from\"C:/Users/user/hub/web-7/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js\";import _classPrivateFieldLooseKey from\"C:/Users/user/hub/web-7/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js\";import{Component}from'react';import{TodoPage}from'../pages/TodoPage/TodoPage';import{createBrowserRouter,RouterProvider}from'react-router-dom';import{Layout}from'../pages/Layout';import{AppContext}from'./context';// Создание роутера приложения, который в зависимости от url отрисовывает\n// определенную компоненту\n// Ссылка на документацию: https://reactrouter.com/en/main/start/tutorial (демонстрация нового API)\n// Ссылка на видеокурс по маршрутизации: https://www.youtube.com/playlist?list=PLiZoB8JBsdznY1XwBcBhHL9L7S_shPGVE (старый API, но смысл такой же)\nimport{jsx as _jsx}from\"react/jsx-runtime\";const router=createBrowserRouter([{// Корневая компонента по url: \"/\". Она отрисовывает лэйаут приложения,\n// куда подставляется контент странички\npath:'/',element:/*#__PURE__*/_jsx(Layout,{}),// Вложенные роуты, которые будут подставляться в лэйаут\nchildren:[{// Это свойство позволяет задать элемент по умолчанию для родительского роута\n// То есть, если в адресной строке url будет \"/\", то отрисуется этот element\nindex:true,element:/*#__PURE__*/_jsx(\"h1\",{children:\"\\u0413\\u043B\\u0430\\u0432\\u043D\\u0430\\u044F \\u0441\\u0442\\u0440\\u0430\\u043D\\u0438\\u0446\\u0430\"})},{path:'/login',element:/*#__PURE__*/_jsx(\"h1\",{children:\"\\u041B\\u043E\\u0433\\u0438\\u043D\"})},{path:'/todos',element:/*#__PURE__*/_jsx(TodoPage,{}),index:true},{path:'/register',element:/*#__PURE__*/_jsx(\"h1\",{children:\"\\u0420\\u0435\\u0433\\u0438\\u0441\\u0442\\u0440\\u0430\\u0446\\u0438\\u044F\"})}]},{// Другой корневой url-путь, который тоже может содержать лейаут, а может и нет\npath:'/root',element:/*#__PURE__*/_jsx(\"h2\",{children:\"\\u0414\\u0440\\u0443\\u0433\\u043E\\u0439 \\u043B\\u0435\\u0439\\u0430\\u0443\\u0442\"})}]);// Компонента приложения, которая содержит состояние приложения. Именно она вмортируется в div#root, который\n// описан в index.html\nvar _login=/*#__PURE__*/_classPrivateFieldLooseKey(\"login\");var _logout=/*#__PURE__*/_classPrivateFieldLooseKey(\"logout\");export class App extends Component{constructor(props){super(props);// Задаем объект пользователя\n// Метод, имитирующий процесс выхода из приложения\nObject.defineProperty(this,_logout,{value:_logout2});// Метод, имитирующий процесс авторизации пользователя\nObject.defineProperty(this,_login,{value:_login2});this.state={user:undefined};}// Метод отрисовки компоненты\nrender(){return(/*#__PURE__*/// Провайдинг контекста. Контекст работает по принципу шины. Через него компонента App\n// предоставляет данные дочерним компонентам. Использование контекста позволяет избежать такой проблемы\n// как props drilling или сквозной передачи пропсов через множество компонент.\n// Контекст имеет пропс value, куда мы передаем объект, содержащий данные контекста\n// Видеоролик по React Context: https://www.youtube.com/watch?v=W_-TO_reSGs\n// В этом ролике автор показывает синтаксис работы с контекстом для функциональных компонент. В целом можете использовать пример,\n// который рассматривали на семинар, но так же можете воспользоваться примером из урока\n_jsx(AppContext.Provider,{value:{user:this.state.user,login:_classPrivateFieldLooseBase(this,_login)[_login].bind(this),logout:_classPrivateFieldLooseBase(this,_logout)[_logout].bind(this)},children:/*#__PURE__*/_jsx(RouterProvider,{router:router})}));}}function _login2(){this.setState({user:{name:'Вася Пупкин',email:'Почта'}});}function _logout2(){this.setState({user:undefined});}","map":{"version":3,"names":["Component","TodoPage","createBrowserRouter","RouterProvider","Layout","AppContext","jsx","_jsx","router","path","element","children","index","_login","_classPrivateFieldLooseKey","_logout","App","constructor","props","Object","defineProperty","value","_logout2","_login2","state","user","undefined","render","Provider","login","_classPrivateFieldLooseBase","bind","logout","setState","name","email"],"sources":["C:/Users/user/hub/web-7/src/app/App.js"],"sourcesContent":["import { Component } from 'react'\r\nimport { TodoPage } from '../pages/TodoPage/TodoPage';\r\nimport { createBrowserRouter, RouterProvider } from 'react-router-dom';\r\nimport { Layout } from '../pages/Layout';\r\nimport { AppContext } from './context';\r\n\r\n// Создание роутера приложения, который в зависимости от url отрисовывает\r\n// определенную компоненту\r\n// Ссылка на документацию: https://reactrouter.com/en/main/start/tutorial (демонстрация нового API)\r\n// Ссылка на видеокурс по маршрутизации: https://www.youtube.com/playlist?list=PLiZoB8JBsdznY1XwBcBhHL9L7S_shPGVE (старый API, но смысл такой же)\r\nconst router = createBrowserRouter([\r\n    {\r\n        // Корневая компонента по url: \"/\". Она отрисовывает лэйаут приложения,\r\n        // куда подставляется контент странички\r\n        path: '/',\r\n        element: <Layout />,\r\n        // Вложенные роуты, которые будут подставляться в лэйаут\r\n        children: [\r\n            {\r\n                // Это свойство позволяет задать элемент по умолчанию для родительского роута\r\n                // То есть, если в адресной строке url будет \"/\", то отрисуется этот element\r\n                index: true,\r\n                element: <h1>Главная страница</h1>\r\n            },\r\n            {\r\n                path: '/login',\r\n                element: <h1>Логин</h1>\r\n            },\r\n            {\r\n                path: '/todos',\r\n                element: <TodoPage />,\r\n                index: true\r\n            },\r\n            {\r\n                path: '/register',\r\n                element: <h1>Регистрация</h1>\r\n            }\r\n        ]\r\n    },\r\n    {\r\n        // Другой корневой url-путь, который тоже может содержать лейаут, а может и нет\r\n        path: '/root',\r\n        element: <h2>Другой лейаут</h2>\r\n    }\r\n])\r\n\r\n// Компонента приложения, которая содержит состояние приложения. Именно она вмортируется в div#root, который\r\n// описан в index.html\r\nexport class App extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        // Задаем объект пользователя\r\n        this.state = {\r\n            user: undefined\r\n        };\r\n    }\r\n\r\n    // Метод отрисовки компоненты\r\n    render() {\r\n        return (\r\n            // Провайдинг контекста. Контекст работает по принципу шины. Через него компонента App\r\n            // предоставляет данные дочерним компонентам. Использование контекста позволяет избежать такой проблемы\r\n            // как props drilling или сквозной передачи пропсов через множество компонент.\r\n            // Контекст имеет пропс value, куда мы передаем объект, содержащий данные контекста\r\n            // Видеоролик по React Context: https://www.youtube.com/watch?v=W_-TO_reSGs\r\n            // В этом ролике автор показывает синтаксис работы с контекстом для функциональных компонент. В целом можете использовать пример,\r\n            // который рассматривали на семинар, но так же можете воспользоваться примером из урока\r\n           <AppContext.Provider value={{\r\n                user: this.state.user,\r\n                login: this.#login.bind(this),\r\n                logout: this.#logout.bind(this)\r\n            }}>\r\n                {/* // Компонента провайдинга роутера. Ее использование важно для работы маршрутизации приложения\r\n                // Чтобы роутер заработал, ему необходмо передатать объект конфигурации роутера в качестве пропса */}\r\n                <RouterProvider router={router} />\r\n           </AppContext.Provider>\r\n        );\r\n    }\r\n\r\n    // Метод, имитирующий процесс авторизации пользователя\r\n    #login() {\r\n        this.setState({\r\n            user: {\r\n                name: 'Вася Пупкин',\r\n                email: 'Почта'\r\n            }\r\n        })\r\n    }\r\n\r\n    // Метод, имитирующий процесс выхода из приложения\r\n    #logout() {\r\n        this.setState({\r\n            user: undefined\r\n        })\r\n    }\r\n}"],"mappings":"4QAAA,OAASA,SAAS,KAAQ,OAAO,CACjC,OAASC,QAAQ,KAAQ,4BAA4B,CACrD,OAASC,mBAAmB,CAAEC,cAAc,KAAQ,kBAAkB,CACtE,OAASC,MAAM,KAAQ,iBAAiB,CACxC,OAASC,UAAU,KAAQ,WAAW,CAEtC;AACA;AACA;AACA;AAAA,OAAAC,GAAA,IAAAC,IAAA,yBACA,KAAM,CAAAC,MAAM,CAAGN,mBAAmB,CAAC,CAC/B,CACI;AACA;AACAO,IAAI,CAAE,GAAG,CACTC,OAAO,cAAEH,IAAA,CAACH,MAAM,GAAE,CAAC,CACnB;AACAO,QAAQ,CAAE,CACN,CACI;AACA;AACAC,KAAK,CAAE,IAAI,CACXF,OAAO,cAAEH,IAAA,OAAAI,QAAA,CAAI,6FAAgB,CAAI,CACrC,CAAC,CACD,CACIF,IAAI,CAAE,QAAQ,CACdC,OAAO,cAAEH,IAAA,OAAAI,QAAA,CAAI,gCAAK,CAAI,CAC1B,CAAC,CACD,CACIF,IAAI,CAAE,QAAQ,CACdC,OAAO,cAAEH,IAAA,CAACN,QAAQ,GAAE,CAAC,CACrBW,KAAK,CAAE,IACX,CAAC,CACD,CACIH,IAAI,CAAE,WAAW,CACjBC,OAAO,cAAEH,IAAA,OAAAI,QAAA,CAAI,oEAAW,CAAI,CAChC,CAAC,CAET,CAAC,CACD,CACI;AACAF,IAAI,CAAE,OAAO,CACbC,OAAO,cAAEH,IAAA,OAAAI,QAAA,CAAI,2EAAa,CAAI,CAClC,CAAC,CACJ,CAAC,CAEF;AACA;AAAA,IAAAE,MAAA,cAAAC,0BAAA,cAAAC,OAAA,cAAAD,0BAAA,WACA,MAAO,MAAM,CAAAE,GAAG,QAAS,CAAAhB,SAAU,CAC/BiB,WAAWA,CAACC,KAAK,CAAE,CACf,KAAK,CAACA,KAAK,CAAC,CAEZ;AAsCJ;AAAAC,MAAA,CAAAC,cAAA,MAAAL,OAAA,EAAAM,KAAA,CAAAC,QAAA,GAVA;AAAAH,MAAA,CAAAC,cAAA,MAAAP,MAAA,EAAAQ,KAAA,CAAAE,OAAA,GA3BI,IAAI,CAACC,KAAK,CAAG,CACTC,IAAI,CAAEC,SACV,CAAC,CACL,CAEA;AACAC,MAAMA,CAAA,CAAG,CACL,oBACI;AACA;AACA;AACA;AACA;AACA;AACA;AACDpB,IAAA,CAACF,UAAU,CAACuB,QAAQ,EAACP,KAAK,CAAE,CACvBI,IAAI,CAAE,IAAI,CAACD,KAAK,CAACC,IAAI,CACrBI,KAAK,CAAEC,2BAAA,KAAI,CAAAjB,MAAA,EAAAA,MAAA,EAAQkB,IAAI,CAAC,IAAI,CAAC,CAC7BC,MAAM,CAAEF,2BAAA,KAAI,CAAAf,OAAA,EAAAA,OAAA,EAASgB,IAAI,CAAC,IAAI,CAClC,CAAE,CAAApB,QAAA,cAGEJ,IAAA,CAACJ,cAAc,EAACK,MAAM,CAAEA,MAAO,CAAE,CAAC,CAClB,CAAC,EAE7B,CAkBJ,CAAC,SAAAe,QAAA,CAfY,CACL,IAAI,CAACU,QAAQ,CAAC,CACVR,IAAI,CAAE,CACFS,IAAI,CAAE,aAAa,CACnBC,KAAK,CAAE,OACX,CACJ,CAAC,CAAC,CACN,CAAC,SAAAb,SAAA,CAGS,CACN,IAAI,CAACW,QAAQ,CAAC,CACVR,IAAI,CAAEC,SACV,CAAC,CAAC,CACN","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}